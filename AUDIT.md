# Аудит проекта LLM Router

## Общая информация

**Проект:** LLM Router - API-шлюз для различных языковых моделей  
**Дата аудита:** 2025-10-03  
**Версия:** Текущая основная ветка  
**Общая оценка:** 7.5/10

## 1. Анализ общей архитектуры и структуры директорий

### 1.1 Архитектура проекта

Проект реализует многослойную архитектуру:

```
nnp-llm-router/
├── config/                 # Конфигурационные файлы
│   ├── models.yaml        # Определение моделей
│   ├── providers.yaml     # Настройки провайдеров
│   └── user_keys.yaml     # Управление ключами доступа
├── src/                   # Исходный код
│   ├── api/              # API слой
│   │   ├── main.py       # Основное приложение FastAPI
│   │   └── middleware.py # Middleware для логирования
│   ├── core/             # Ядро системы
│   │   ├── auth.py       # Аутентификация
│   │   ├── config_manager.py # Управление конфигурацией
│   │   └── exceptions.py # Пользовательские исключения
│   ├── services/         # Сервисы бизнес-логики
│   │   ├── chat_service.py
│   │   ├── model_service.py
│   │   ├── embedding_service.py
│   │   └── transcription_service.py
│   ├── providers/        # Адаптеры провайдеров
│   │   ├── base.py       # Базовый класс провайдера
│   │   ├── openai.py     # OpenAI-совместимые провайдеры
│   │   ├── anthropic.py  # Anthropic провайдер
│   │   └── ollama.py     # Ollama провайдер
│   ├── utils/            # Утилиты
│   │   ├── cost_calculator.py
│   │   └── deep_merge.py
│   └── logging/          # Система логирования
│       └── config.py
├── tests/                # Тесты
├── tools/                # Инструменты
└── Docker файлы          # Контейнеризация
```

### 1.2 Оценка архитектуры

**Положительные аспекты:**
- Четкое разделение на слои (API, Services, Providers)
- Использование паттерна Adapter для интеграции провайдеров
- Конфигурационное управление через YAML файлы
- Поддержка Docker для развертывания
- Централизованная система логирования

**Проблемы:**
- Отсутствие явного определения интерфейсов (протоколов) для провайдеров
- Смешение ответственности в некоторых сервисах
- Недостаточная абстракция для обработки разных типов запросов

## 2. Организация кода в модулях и пакетах

### 2.1 API модуль (src/api/)

**main.py (117 строк)**
- **Ответственности:** Определение FastAPI приложения, настройка middleware, определение роутов, инициализация сервисов
- **Проблемы:** Слишком много логики в startup/shutdown событиях, отсутствие группировки роутов через APIRouter
- **Рекомендации:** Вынести инициализацию в отдельный модуль, использовать APIRouter

**middleware.py (85 строк)**
- **Ответственности:** Логирование запросов, обработка ошибок, добавление метаданных
- **Оценка:** ✅ Хорошо соответствует SRP

### 2.2 Core модуль (src/core/)

**auth.py (43 строки)**
- **Ответственности:** Извлечение API ключа, валидация, определение разрешенных моделей
- **Оценка:** ✅ Отлично соответствует SRP

**config_manager.py (96 строк)**
- **Ответственности:** Загрузка конфигурации, отслеживание изменений, перезагрузка
- **Проблемы:** Смешение загрузки и отслеживания, тестовый код в основном файле
- **Рекомендации:** Разделить на ConfigLoader и ConfigWatcher, удалить тестовый код

**exceptions.py (24 строки)**
- **Ответственности:** Определение пользовательских исключений
- **Оценка:** ✅ Идеально соответствует SRP

### 2.3 Services модуль (src/services/)

**chat_service.py (431 строка)**
- **Ответственности:** Валидация запросов, обработка стриминга, преобразование форматов, логирование
- **Проблемы:** Слишком много ответственностей, самый большой файл в проекте
- **Рекомендации:** Разделить на ChatValidator, StreamingHandler, ChatProcessor

**model_service.py (185 строк)**
- **Ответственности:** Получение списка моделей, детальная информация, взаимодействие с API
- **Оценка:** ✅ Хорошо соответствует SRP

**embedding_service.py (120 строк)**
- **Ответственности:** Валидация запросов эмбеддингов, обработка, логирование
- **Оценка:** ✅ Соответствует SRP

**transcription_service.py (90 строк)**
- **Ответственности:** Валидация моделей, обработка аудио, взаимодействие с провайдерами
- **Оценка:** ✅ Соответствует SRP

### 2.4 Providers модуль (src/providers/)

**base.py (87 строк)**
- **Ответственности:** Определение интерфейса, обработка HTTP запросов, управление заголовками
- **Проблемы:** Смешение интерфейса и реализации HTTP-клиента
- **Рекомендации:** Выделить HTTP-клиент в отдельный компонент

**openai.py (155 строк)**
- **Ответственности:** Обработка чата, эмбеддингов, транскрипций
- **Проблемы:** Один класс обрабатывает три разных типа запросов
- **Рекомендации:** Разделить на OpenAIChatProvider, OpenAIEmbeddingProvider, OpenAITranscriptionProvider

**anthropic.py (60 строк)**
- **Ответственности:** Обработка чат-запросов Anthropic
- **Оценка:** ✅ Соответствует SRP

**ollama.py (103 строки)**
- **Ответственности:** Обработка чата и эмбеддингов Ollama
- **Проблемы:** Смешение чата и эмбеддингов
- **Рекомендации:** Разделить на два класса

## 3. Анализ соответствия принципу единственной ответственности (SRP)

### 3.1 Нарушения SRP

**Критические нарушения:**

1. **ChatService (431 строка)**
   - Валидация запросов
   - Обработка стриминга
   - Преобразование форматов
   - Логирование
   - Буферизация UTF-8
   - Обработка SSE/NDJSON

2. **OpenAICompatibleProvider (155 строк)**
   - Обработка чат-запросов
   - Обработка эмбеддингов
   - Обработка транскрипций

3. **ConfigManager (96 строк)**
   - Загрузка конфигурации
   - Отслеживание изменений
   - Перезагрузка конфигурации

4. **BaseProvider (87 строк)**
   - Определение интерфейса
   - Реализация HTTP-клиента
   - Обработка стриминга

### 3.2 Рекомендации по исправлению

1. **Разделить ChatService:**
   ```python
   class ChatValidator:
       """Валидация чат-запросов"""
   
   class StreamingHandler:
       """Обработка стриминга"""
   
   class ChatProcessor:
       """Основная логика обработки"""
   
   class ChatLogger:
       """Логирование чат-операций"""
   ```

2. **Разделить OpenAI провайдер:**
   ```python
   class OpenAIChatProvider(BaseProvider):
       """Обработка чат-запросов"""
   
   class OpenAIEmbeddingProvider(BaseProvider):
       """Обработка эмбеддингов"""
   
   class OpenAITranscriptionProvider(BaseProvider):
       """Обработка транскрипций"""
   ```

## 4. Анализ обработки ошибок и исключений

### 4.1 Система исключений

**Пользовательские исключения (src/core/exceptions.py):**
- `ProviderStreamError` - ошибки стриминга
- `ProviderAPIError` - ошибки API провайдеров
- `ProviderNetworkError` - сетевые ошибки

**Оценка:** ✅ Хорошая иерархия с дополнительной информацией

### 4.2 Обработка ошибок в сервисах

**ChatService:**
- Комплексная обработка `httpx.HTTPStatusError`, `httpx.RequestError`, `HTTPException`
- Специализированная обработка ошибок стриминга
- Преобразование ошибок в стандартный формат

**EmbeddingService & TranscriptionService:**
- Упрощенная обработка ошибок
- Нет обработки специфических ошибок провайдеров

### 4.3 Проблемы обработки ошибок

1. **Несогласованность:** Разные сервисы обрабатывают ошибки по-разному
2. **Дублирование:** Похожие блоки обработки ошибок повторяются
3. **Неполное использование:** Не все провайдеры используют пользовательские исключения
4. **Потеря контекста:** Некоторые ошибки теряют исходный контекст

### 4.4 Рекомендации

1. Создать централизованный обработчик ошибок
2. Использовать пользовательские исключения во всех провайдерах
3. Создать базовый класс для обработки ошибок в сервисах
4. Добавить больше контекста к ошибкам

## 5. Анализ системы логирования и мониторинга

### 5.1 Конфигурация логирования

**Компоненты (src/logging/config.py):**
- `JsonFormatter` - форматировщик JSON логов
- `setup_logging()` - инициализация логирования

**Особенности:**
- Структурированные JSON логи
- Поддержка кастомных полей через `extra`
- Двойной вывод: в файл и консоль
- Автоматическое создание директории

**Поля логирования:**
- Базовые: request_id, user_id, model_id, log_type
- HTTP: method, url, http_status_code, process_time_ms
- LLM: prompt_tokens, completion_tokens, total_tokens
- Стоимость: prompt_cost, completion_cost, total_cost
- Ошибки: error_message, error_code, detail

**Оценка:** ✅ Отличная система структурированного логирования

### 5.2 Логирование в компонентах

**Middleware (src/api/middleware.py):**
- Генерация уникального request_id
- Логирование жизненного цикла запроса
- Детальное логирование ошибок

**Сервисы:**
- ChatService: логирование с контентом первого сообщения
- EmbeddingService: логирование типа и длины input
- ModelService: логирование ошибок при получении моделей

### 5.3 Проблемы мониторинга

1. **Отсутствие агрегации метрик:** Нет сбора агрегированных метрик
2. **Ограниченное бизнес-логирование:** Нет логирования популярности моделей
3. **Производительность:** JSON форматирование может быть медленным
4. **Управление логами:** Нет ротации и очистки

### 5.4 Рекомендации

1. Добавить систему метрик (Prometheus/Grafana)
2. Реализовать ротацию логов
3. Добавить алерты для критических ошибок
4. Оптимизировать производительность логирования

## 6. Анализ конфигурационного управления

### 6.1 Структура конфигурации

**providers.yaml:** Определяет провайдеров с типом, base_url, api_key_env
**models.yaml:** Определяет модели с привязкой к провайдерам
**user_keys.yaml:** Управляет API ключами и разрешенными моделями

**Оценка:** ✅ Четкое разделение конфигурации по доменам

### 6.2 ConfigManager

**Функциональность:**
- Загрузка из YAML файлов
- Автоматическая перезагрузка при изменении
- Кэширование в памяти
- Проверка изменений каждые 5 секунд

**Оценка:** ✅ Хорошая реализация динамической конфигурации

### 6.3 Проблемы конфигурации

1. **Безопасность:** API ключи в переменных окружения без шифрования
2. **Обработка ошибок:** Молчаливое игнорирование отсутствующих файлов
3. **Производительность:** Проверка изменений каждые 5 секунд
4. **Масштабируемость:** Нет поддержки окружений (dev/staging/prod)

### 6.4 Конкретные проблемы

**Тестовый код в основном файле:**
```python
# src/core/config_manager.py:79-96
if __name__ == "__main__":
    # Create dummy config files for testing
```

**Обработка ошибок:**
```python
# src/core/config_manager.py:25-27
except FileNotFoundError as e:
    pass # Silently ignore missing files for now
```

### 6.5 Рекомендации

1. Добавить валидацию конфигурации через Pydantic
2. Улучшить безопасность (шифрование, audit)
3. Оптимизировать производительность (watchfiles)
4. Добавить поддержку окружений

## 7. Анализ безопасности и управления доступом

### 7.1 Аутентификация и авторизация

**Механизм (src/core/auth.py):**
- Использование Bearer токенов
- Валидация через конфигурацию
- Извлечение project_name
- Проверка разрешенных моделей

**Оценка:** ✅ Базовая аутентификация реализована корректно

### 7.2 Проблемы безопасности

**Критические проблемы:**

1. **Управление API ключами:**
   - Ключи хранятся в открытом виде
   - Нет механизма ротации
   - Нет проверки срока действия
   - Нет отзыва скомпрометированных ключей

2. **Безопасность передачи данных:**
   - Использование HTTP для локальных провайдеров
   - Нет валидации SSL сертификатов
   - Нет защиты от MITM атак

3. **Контроль доступа:**
   - Нет ограничений по частоте запросов
   - Нет ограничений по количеству токенов
   - Нет IP-фильтрации

4. **Логирование безопасности:**
   - API ключи могут попасть в логи
   - Нет аудита доступа
   - Нет детектирования аномальной активности

### 7.3 Уязвимости в коде

**Потенциальная утечка API ключей:**
```python
# src/core/auth.py:57-60
if hasattr(record, 'api_key'):
    log_record['api_key'] = record.api_key
```

**Недостаточная валидация:**
```python
# src/api/main.py:84-113
@app.post("/v1/audio/transcriptions")
async def create_transcription(
    # Нет валидации размера файла
    audio_file: Optional[UploadFile] = File(None),
```

**Открытое хранение ключей:**
```python
# config/user_keys.yaml
user_keys:
  debug:
    api_key: dummy  # Открытый текст
  continue:
    api_key: nnp-v1-91afa1510b7e0c9d27b713ac0cc7a458775271f348d86c7ae823bf08f891e89a
```

### 7.4 Рекомендации по безопасности

1. **Управление ключами:**
   - Хранить хэши ключей
   - Реализовать ротацию
   - Добавить срок действия
   - Реализовать отзыв

2. **Усиление контроля доступа:**
   - Добавить rate limiting
   - Ввести квоты
   - Реализовать IP-фильтрацию
   - Добавить MFA

3. **Защита данных:**
   - Использовать HTTPS
   - Валидировать SSL
   - Шифровать чувствительные данные
   - Добавить валидацию входных данных

## 8. Анализ производительности и оптимизации

### 8.1 HTTP клиент и соединения

**Особенности:**
- Асинхронный httpx клиент
- Настройка таймаутов для разных типов запросов
- Переиспользование клиента через app.state

**Таймауты в провайдерах:**
```python
# src/providers/openai.py:35-40
non_stream_timeout = httpx.Timeout(
    connect=10.0,
    read=60.0,
    write=10.0,
    pool=10.0
)
```

**Оценка:** ✅ Хорошая настройка таймаутов

### 8.2 Обработка стриминга

**Оптимизации в ChatService:**
- UTF-8 incremental decoder
- Буферизация SSE/JSON событий
- Авто-определение формата стрима
- Оптимизированная обработка границ чанков

**Оценка:** ✅ Отличная оптимизация стриминга

### 8.3 Проблемы производительности

1. **Блокирующие операции:**
   ```python
   # src/core/config_manager.py:53-73
   async def _reload_config_task(self):
       while True:
           # Блокирующая проверка файлов каждые 5 секунд
           mtime = os.path.getmtime(fpath)  # Блокирующий I/O
   ```

2. **Неэффективное использование памяти:**
   ```python
   # src/services/chat_service.py:165-166
   sse_buffer = ""
   json_buffer = ""
   # Буферы могут расти неограниченно
   ```

3. **Дублирование валидации:**
   - Валидация модели повторяется в каждом сервисе
   - Нет кэширования валидированных конфигураций

4. **Отсутствие connection pooling:**
   - httpx клиент не настроен для оптимального pooling
   - Нет лимитов на количество соединений

### 8.4 Узкие места

1. **Стриминг больших ответов:** Буферизация может потреблять много памяти
2. **Обработка файлов транскрипций:** Загрузка файла целиком в память
3. **Логирование при высокой нагрузке:** JSON форматирование в каждом запросе
4. **Конфигурационный менеджер:** Частая проверка файлов

### 8.5 Рекомендации по оптимизации

1. **Оптимизация HTTP клиента:**
   ```python
   limits = httpx.Limits(max_keepalive_connections=20, max_connections=100)
   client = httpx.AsyncClient(limits=limits)
   ```

2. **Асинхронное отслеживание файлов:**
   ```python
   from watchfiles import awatch
   async def watch_config():
       async for changes in awatch(config_dir):
           await reload_config()
   ```

3. **Оптимизация логирования:**
   ```python
   executor = ThreadPoolExecutor(max_workers=2)
   async def log_async(data):
       loop = asyncio.get_event_loop()
       await loop.run_in_executor(executor, log_sync, data)
   ```

4. **Кэширование валидации:**
   ```python
   @lru_cache(maxsize=128)
   def validate_model(model_id: str, allowed_models: List[str]):
   ```

## 9. Анализ тестирования и качества кода

### 9.1 Структура тестов

**Тестовые файлы:**
- `test_models.py` - тестирование моделей и API
- `test_hidden_models.py` - тестирование скрытых моделей
- `test_streaming_fixes.py` - тестирование стриминга
- `TESTS.md` - документация по тестированию
- `transcription.ogg` - тестовый аудиофайл

**Оценка:** ✅ Хорошая организация тестов

### 9.2 Покрытие функциональности

**Тестируемые сценарии:**
- ✅ Базовые health check
- ✅ Получение списка моделей
- ✅ Получение конкретной модели
- ✅ Скрытые модели
- ✅ Чат с разными моделями
- ✅ Транскрипции аудио
- ✅ Стриминг с разными языками и emoji
- ✅ Обработка ошибок

**Оценка:** ✅ Хороший охват основных сценариев

### 9.3 Качество тестов

**Пример теста:**
```python
def test_health_check():
    response = requests.get(f"{BASE_URL}/health")
    assert response.status_code == 200
    assert response.json() == {"status": "ok"}
```

**Особенности:**
- ✅ Простые и понятные тесты
- ✅ Проверка статус кодов
- ✅ Валидация структуры ответов
- ⚠️ Нет параметризованных тестов
- ⚠️ Нет mock объектов для изоляции

### 9.4 Качество кода

**Стиль кода:**
- ✅ Правильные отступы (4 пробела)
- ✅ Именование переменных и функций
- ✅ Длина строк (в основном)
- ⚠️ Некоторые строки слишком длинные

**Документация:**
- ⚠️ Методы классов не имеют docstrings
- ⚠️ Нет документации для параметров
- ⚠️ Нет описания возвращаемых значений

**Типизация:**
- ✅ Базовая типизация параметров
- ✅ Типизация возвращаемых значений
- ⚠️ Нет строгой типизации для сложных структур
- ⚠️ Использование Any во многих местах

### 9.5 Проблемы в тестировании

1. **Отсутствие автоматизации:** Нет CI/CD для запуска тестов
2. **Изоляция тестов:** Тесты зависят от внешних сервисов
3. **Покрытие кода:** Нет измерения покрытия кода
4. **Нагрузочное тестирование:** Нет тестов производительности

### 9.6 Рекомендации по улучшению

1. **Улучшение тестов:**
   ```python
   @pytest.mark.parametrize("model_id,expected_status", [
       ("deepseek/chat", 200),
       ("invalid_model", 404),
   ])
   def test_model_access(model_id, expected_status):
   ```

2. **Добавить mock объекты:**
   ```python
   from unittest.mock import AsyncMock, patch
   @patch('src.providers.openai.httpx.AsyncClient')
   def test_chat_with_mock(mock_client):
   ```

3. **Улучшить документацию:**
   ```python
   async def chat_completions(
       self, 
       request: Request, 
       auth_data: Tuple[str, str, list]
   ) -> Union[StreamingResponse, JSONResponse]:
       """
       Process chat completion requests.
       
       Args:
           request: FastAPI Request object
           auth_data: Tuple of (project_name, api_key, allowed_models)
       
       Returns:
           StreamingResponse for streaming requests or JSONResponse for non-streaming
       
       Raises:
           HTTPException: For validation or provider errors
       """
   ```

## 10. Сводка проблем и технический долг

### 10.1 Критические проблемы

| Проблема | Компонент | Влияние | Усилия для исправления |
|----------|-----------|---------|------------------------|
| Нарушение SRP | ChatService | Высокое | 2-3 недели |
| Открытое хранение ключей | config/user_keys.yaml | Критическое | 1-2 недели |
| Отсутствие rate limiting | auth.py | Высокое | 1 неделя |
| Блокирующая проверка конфигурации | config_manager.py | Среднее | 1 неделя |

### 10.2 Серьезные проблемы

| Проблема | Компонент | Влияние | Усилия для исправления |
|----------|-----------|---------|------------------------|
| Дублирование кода валидации | Все сервисы | Среднее | 1 неделя |
| Отсутствие интерфейсов провайдеров | providers/ | Среднее | 1-2 недели |
| Синхронное логирование | logging/ | Среднее | 1 неделя |
| Неограниченные буферы | chat_service.py | Среднее | 3-5 дней |

### 10.3 Менее критичные проблемы

| Проблема | Компонент | Влияние | Усилия для исправления |
|----------|-----------|---------|------------------------|
| Отсутствие docstrings | Все файлы | Низкое | 3-5 дней |
| Тесты зависят от внешних сервисов | tests/ | Низкое | 1 неделя |
| Нет покрытия кода | tests/ | Низкое | 3-5 дней |
| Нет агрегации метрик | logging/ | Низкое | 1 неделя |

## 11. Рекомендации по улучшению

### 11.1 Приоритет 1: Критические исправления (1-2 недели)

1. **Рефакторинг ChatService**
   ```python
   # Создать компоненты
   class ChatValidator:
       """Валидация запросов"""
   
   class StreamingHandler:
       """Обработка стриминга"""
   
   class ChatProcessor:
       """Основная логика"""
   
   class ChatLogger:
       """Логирование операций"""
   ```

2. **Усиление безопасности**
   ```python
   # Хеширование ключей
   import hashlib
   def hash_api_key(api_key: str) -> str:
       return hashlib.sha256(api_key.encode()).hexdigest()
   
   # Rate limiting
   from slowapi import Limiter
   limiter = Limiter(key_func=get_remote_address)
   
   @app.post("/v1/chat/completions")
   @limiter.limit("100/minute")
   async def chat_completions(request: Request):
   ```

3. **Создание интерфейсов**
   ```python
   from typing import Protocol
   
   class LLMProvider(Protocol):
       async def chat_completions(self, request: dict, model: str, config: dict) -> Any:
           ...
       
       async def embeddings(self, request: dict, model: str, config: dict) -> Any:
           ...
   ```

### 11.2 Приоритет 2: Серьезные улучшения (2-3 недели)

1. **Оптимизация конфигурации**
   ```python
   # Использовать watchfiles вместо опроса
   from watchfiles import awatch
   
   async def watch_config():
       async for changes in awatch(config_dir):
           await reload_config()
   ```

2. **Валидация конфигурации**
   ```python
   from pydantic import BaseModel, validator
   
   class ProviderConfig(BaseModel):
       type: str
       base_url: HttpUrl
       api_key_env: Optional[str] = None
       
       @validator('type')
       def validate_type(cls, v):
           if v not in ['openai', 'ollama', 'anthropic']:
               raise ValueError(f'Unsupported provider type: {v}')
           return v
   ```

3. **Унификация обработки ошибок**
   ```python
   class ErrorHandler:
       @staticmethod
       def handle_provider_error(error: Exception) -> HTTPException:
           if isinstance(error, httpx.HTTPStatusError):
               return HTTPException(
                   status_code=error.response.status_code,
                   detail={"error": {"message": error.response.text, "code": "provider_error"}}
               )
           # Другие типы ошибок
   ```

### 11.3 Приоритет 3: Улучшения качества (1-2 недели)

1. **Улучшение тестирования**
   - Добавить mock объекты для изоляции тестов
   - Внедрить CI/CD для автоматического тестирования
   - Добавить измерение покрытия кода

2. **Мониторинг и метрики**
   ```python
   from prometheus_client import Counter, Histogram
   
   REQUEST_COUNT = Counter('requests_total', 'Total requests', ['method', 'endpoint'])
   REQUEST_DURATION = Histogram('request_duration_seconds', 'Request duration')
   ```

3. **Документация**
   - Добавить docstrings для всех методов
   - Создать архитектурную документацию
   - Добавить примеры использования

## 12. План внедрения

### Неделя 1-2: Критические исправления
- Разделить ChatService на компоненты
- Внедрить хеширование API ключей
- Добавить базовый rate limiting
- Создать интерфейсы провайдеров

### Неделя 3-4: Серьезные улучшения
- Оптимизировать конфигурационный менеджер
- Добавить валидацию конфигурации
- Унифицировать обработку ошибок
- Улучшить производительность логирования

### Неделя 5-6: Качество и мониторинг
- Улучшить тестирование и CI/CD
- Добавить метрики и алерты
- Улучшить документацию
- Провести нагрузочное тестирование

## 13. Заключение

Проект LLM Router демонстрирует высокий уровень технической реализации с отличными решениями в области стриминга, логирования и интеграции провайдеров. Основные проблемы сосредоточены в области архитектуры (нарушение SRP), безопасности (хранение ключей) и производительности (оптимизация конфигурации).

Приоритетные усилия следует сосредоточить на рефакторинге ChatService, улучшении безопасности и оптимизации производительности. После выполнения этих улучшений проект достигнет превосходного уровня качества и будет готов к масштабированию.

**Итоговая оценка: 7.5/10**

После выполнения рекомендаций ожидаемая оценка: 9.5/10